#!/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import subprocess
import sys
import logging
import configparser
from pathlib import Path
import json
import re
import time

# Configure logging to log to the user's home directory
log_file = os.path.join(os.path.expanduser("~"), 'ask_openai.log')
logging.basicConfig(filename=log_file, level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Function to show message using Zenity
def show_message(title, text):
    proc = subprocess.Popen(['zenity', '--text-info', '--title', title, '--width=600', '--height=400'], stdin=subprocess.PIPE, text=True)
    proc.communicate(input=text)

# Read API key from configuration file or environment variable
def read_api_key():
    api_key = os.getenv('OPENAI_API_KEY')
    if api_key:
        logging.debug("API key read from environment variable.")
        return api_key
    
    config_path = Path.home() / '.ask_openai.conf'
    if config_path.exists():
        config = configparser.ConfigParser()
        config.read(config_path)
        api_key = config.get('openai', 'api_key', fallback=None)
        
        if api_key:
            logging.debug("API key read from configuration file.")
            return api_key
        
    message = "API key is not set. Please set the API key in the configuration file or as an environment variable."
    logging.error(message)
    show_message("Error", message)
    raise EnvironmentError(message)

api_key = read_api_key()

# Function to get the content from the clipboard using xclip or xsel
def get_clipboard_content():
    for attempt in range(3):
        try:
            content = subprocess.check_output(['xclip', '-selection', 'clipboard', '-o'], text=True)
            logging.debug(f"Clipboard content retrieved using xclip on attempt {attempt + 1}: {content}")
            if content.strip() != "":
                return content
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting clipboard content using xclip on attempt {attempt + 1}: {e}")
            time.sleep(1)
        
        try:
            content = subprocess.check_output(['xsel', '--clipboard', '--output'], text=True)
            logging.debug(f"Clipboard content retrieved using xsel on attempt {attempt + 1}: {content}")
            if content.strip() != "":
                return content
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting clipboard content using xsel on attempt {attempt + 1}: {e}")
            time.sleep(1)
    
    return None

# Function to check internet connectivity
def check_internet_connection():
    try:
        subprocess.check_call(['ping', '-c', '1', '8.8.8.8'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logging.debug("Internet connection is available.")
        return True
    except subprocess.CalledProcessError:
        logging.error("No internet connection.")
        return False

# Function to query OpenAI API
def query_openai(model, prompt, api_key):
    if not check_internet_connection():
        show_message("Error", "No internet connection. Please check your network settings.")
        raise RuntimeError("No internet connection.")
    
    try:
        import requests
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        data = {
            "model": model,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 4096
        }
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, data=json.dumps(data))
        logging.debug(f"OpenAI API response status code: {response.status_code}")
        logging.debug(f"OpenAI API response headers: {response.headers}")
        logging.debug(f"OpenAI API response content: {response.content}")
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logging.error(f"Error querying OpenAI API: {e}")
        return None

# Check if the API key is set
if not api_key:
    message = "OpenAI API key is not set. Please set the OPENAI_API_KEY key in configuration file or environment variable"
    if os.getenv("LANG", "en")[:2] == "ko":
        message = "API 키가 설정되지 않았습니다. ~/.ask_openai.conf 파일 또는 환경변수 OPENAI_API_KEY 를 설정해 주세요."
    logging.error(message)
    show_message("Error", message)
    raise EnvironmentError(message)

# Get the content from the clipboard
clipboard_content = get_clipboard_content()
if clipboard_content is None:
    message = "Failed to retrieve clipboard content."
    if os.getenv("LANG", "en")[:2] == "ko":
        message = "클립보드 내용을 가져오는 데 실패했습니다."
    logging.error(message)
    show_message("Error", message)
    raise ValueError(message)

if clipboard_content.strip() == "":
    message = "Clipboard is empty!"
    if os.getenv("LANG", "en")[:2] == "ko":
        message = "클립보드가 비어 있습니다!"
    logging.error(message)
    show_message("Error", message)
    raise ValueError(message)

# Define the pre-defined prompt
if os.getenv("LANG", "en")[:2] == "ko":
    predefined_prompt = """다음 문장이 프로그램 소스코드인 경우 코드에 대한 설명을 해주고, 
    오류 메시지인 경우 사용자가 우분투 24.04 기반의 Cinnamon 데스크톱 환경을 사용하는 
    HamoniKR OS를 사용한다고 가정하고, 먼저 https://hamonikr.org 또는 
    https://docs.hamonikr.org/hamonikr-8.0 에서 관련 문서를 참고해 설명해 주세요. 
    관련 정보를 찾을 수 없는 경우 https://askubuntu.com 에서 관련 내용을 찾아서 
    참고할 수 있는 링크와 함께 설명해 주세요. 모든 응답은 한국어로 해주세요.\n"""
else:
    predefined_prompt = """If the following text is a program source code, please explain the 
    code, and if it is an error message, assume that the user uses a HamoniKR OS that uses 
    Ubuntu 24.04 based Cinnamon desktop environment. First, refer to relevant documents 
    from https://hamonikr.org or https://docs.hamonikr.org/hamonikr-8.0. If no relevant 
    information is found, provide explanations based on related content from 
    https://askubuntu.com, including reference links. Please respond in English.\n"""

# Combine the predefined prompt with the clipboard content
full_prompt = f"{predefined_prompt}{clipboard_content}"
logging.debug(f"Full prompt: {full_prompt}")

# Model to use
# https://openai.com/api/pricing/
model = "gpt-4o-mini"

# Query OpenAI API
response = query_openai(model, full_prompt, api_key)

if response is None:
    logging.error("No response from OpenAI API.")
    if os.getenv("LANG", "en")[:2] == "ko":
        show_message("Error", "OpenAI 응답이 없습니다. API키가 사용가능한지 확인해주세요.")
    else:
        show_message("Error", "No response from OpenAI API. Check your API key.")
    
    raise RuntimeError("No response from OpenAI API.")

# Extract and log the response text
response_text = response.get('choices', [{}])[0].get('message', {}).get('content', 'No response text available.')

# Remove formatting characters like ** and ``` and other language codes
response_text = re.sub(r'\*\*', '', response_text)
response_text = re.sub(r'```[a-z]*', '', response_text)
response_text = response_text.replace('```', '').replace('`', '')

logging.debug(f"OpenAI Response: {response_text}")

# Show the response text in a Zenity dialog with scrolling
if os.getenv("LANG", "en")[:2] == "ko":
    show_message("AI 응답", response_text)
else:
    show_message("OpenAI Response", response_text)
